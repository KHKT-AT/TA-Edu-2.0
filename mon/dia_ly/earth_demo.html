<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tr√°i ƒê·∫•t 3D üåç (Nh·ªè h∆°n, kh√¥ng overlay)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #001015, #000);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: "Poppins", sans-serif;
    }

    .earth-box {
      width: 85vmin;
      height: 85vmin;
      border-radius: 25px;
      border: 2px solid #00ffee;
      box-shadow: 0 0 25px #00ffee88;
      overflow: hidden;
      position: relative;
      background: radial-gradient(circle at center, #000, #000010);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #resetView {
      position: absolute;
      bottom: 25px;
      right: 25px;
      background: linear-gradient(135deg, #ff9de1, #9ef9ff);
      color: #fff;
      font-weight: 600;
      font-size: 16px;
      padding: 12px 20px;
      border: none;
      border-radius: 50px;
      box-shadow: 0 4px 15px rgba(255, 182, 255, 0.4);
      cursor: pointer;
      outline: none;
      transition: all 0.25s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      backdrop-filter: blur(8px);
      user-select: none;
      z-index: 10;
    }

    #resetView:hover {
      background: linear-gradient(135deg, #ffc4eb, #afffff);
      transform: scale(1.05);
      box-shadow: 0 6px 18px rgba(255, 182, 255, 0.6);
    }
  </style>
</head>
<body>
  <div class="earth-box">
    <canvas id="earthCanvas"></canvas>
    <button id="resetView">üåé V·ªã tr√≠ ban ƒë·∫ßu</button>
  </div>

  <script src="https://unpkg.com/three@0.141.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.141.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    window.addEventListener('load', () => {
      const canvas = document.getElementById('earthCanvas');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(33, 1, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(700, 700);
      renderer.setPixelRatio(window.devicePixelRatio);

      const sun = new THREE.DirectionalLight(0xffffff, 1.2);
      sun.position.set(5, 3, 5);
      scene.add(sun);
      scene.add(new THREE.AmbientLight(0x202020, 1));

      const starsGeo = new THREE.BufferGeometry();
      const pts = [];
      for (let i = 0; i < 1500; i++) {
        pts.push((Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400);
      }
      starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
      const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: 0.6, color: 0xffffff }));
      scene.add(stars);

      const tilt = THREE.MathUtils.degToRad(23.5);
      const radius = 0.45;
      const earthGroup = new THREE.Group();
      scene.add(earthGroup);

      const loader = new THREE.TextureLoader();
      const texEarth = loader.load('./earth/earthmap1k.jpg');
      const texBump  = loader.load('./earth/earthbump1k.jpg');
      const texSpec  = loader.load('./earth/earthspec1k.jpg');
      const texCloud = loader.load('./earth/earthcloudmaptrans.jpg');
      const texNight = loader.load('./earth/earthlights1k.jpg');

      const earth = new THREE.Mesh(
        new THREE.SphereGeometry(radius, 128, 128),
        new THREE.MeshPhongMaterial({
          map: texEarth,
          bumpMap: texBump,
          bumpScale: 0.05,
          specularMap: texSpec,
          specular: new THREE.Color('gray'),
          shininess: 10
        })
      );
      earthGroup.add(earth);

      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(radius + 0.01, 128, 128),
        new THREE.MeshPhongMaterial({
          map: texCloud,
          transparent: true,
          opacity: 0.35,
          depthWrite: false
        })
      );
      earthGroup.add(clouds);

      const night = new THREE.Mesh(
        new THREE.SphereGeometry(radius + 0.001, 128, 128),
        new THREE.MeshBasicMaterial({
          map: texNight,
          transparent: true,
          blending: THREE.AdditiveBlending,
          opacity: 0.45
        })
      );
      earthGroup.add(night);

      const axis = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.015, 1.8, 16),
        new THREE.MeshBasicMaterial({ color: 0xff4040 })
      );
      earthGroup.add(axis);

      earthGroup.rotation.z = -tilt;
      const offsetY = Math.sin(tilt) * radius * 0.25;
      earthGroup.position.set(0, -offsetY, 0);

      camera.position.set(0, 0, 3.2);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2.0;
      controls.maxDistance = 4.5;
      controls.target.set(0, 0, 0);
      controls.update();

      const resetBtn = document.getElementById('resetView');
      const initialRotationY = 0;
      let rotationSpeed = 0.001;

      function smoothMove(duration, onUpdate, onComplete) {
        const startTime = performance.now();
        function animate(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const ease = 1 - Math.pow(1 - t, 3);
          onUpdate(ease);
          if (t < 1) requestAnimationFrame(animate);
          else if (onComplete) onComplete();
        }
        requestAnimationFrame(animate);
      }

      resetBtn.addEventListener('click', () => {
        const startPos = camera.position.clone();
        const endPos = new THREE.Vector3(0, 0, 3.2);
        const startTarget = controls.target.clone();
        const endTarget = new THREE.Vector3(0, 0, 0);
        const startRot = earthGroup.rotation.y;

        smoothMove(1000, (t) => {
          camera.position.lerpVectors(startPos, endPos, t);
          controls.target.lerpVectors(startTarget, endTarget, t);
          earthGroup.rotation.y = startRot + (initialRotationY - startRot) * t;
          controls.update();
        });
      });

      const animate = () => {
        requestAnimationFrame(animate);
        earthGroup.rotation.y += rotationSpeed;
        clouds.rotation.y += rotationSpeed * 1.3;
        stars.rotation.y += rotationSpeed * 0.05;
        controls.update();
        renderer.render(scene, camera);
      };
      animate();
    });
  </script>
</body>
</html>